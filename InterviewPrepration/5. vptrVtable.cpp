derived and based classes, virtual table, vptr 


✅ 1. What Are Virtual Functions?
---> A virtual function is a function in a base class that we want to override in derived classes and call polymorphically 
     (i.e., through a base-class pointer/reference).

class Base {
  public:
    virtual void show() { cout << "Base\n"; }
};


Marking a function virtual tells the compiler:
---> “Use runtime lookup to resolve which function to call.”

This introduces the concepts of:
---> vtable → Virtual Table
---> vptr → Virtual Pointer




✅ 2. What Is a vtable?
A vtable (virtual table) is:
---> An array of function pointers generated by the compiler.
---> Each class with virtual functions has its own vtable.
---> Each entry contains the address of the most derived override of a virtual function.





✅ 3. What Is a vptr?
---> Each object of a class with virtual functions contains a hidden pointer called vptr.
---> The compiler silently adds this pointer into the object layout.
---> It points to that class’s vtable.


Object Layout (simplified)
+----------------------+
|     vptr ----------+----> vtable (for that class)
+----------------------+
|   data members       |
+----------------------+





4. Compile-Time vs Runtime Behavior
At Compile Time
Compiler creates:
---> vtable for each class
---> Places addresses of overridden functions
---> Inserts vptr inside each object

At Runtime
---> Each object’s constructor sets vptr to point to the class’s vtable.

A virtual call is executed as:
---> object.vptr -> vtable[function_index] -> call actual overridden function




5. Example with Diagram
C++ Code
#include <iostream>
using namespace std;
class Base {
  public:
    virtual void show() { cout << "Base::show\n"; }
    virtual void display() { cout << "Base::display\n"; }
};
class Derived : public Base {
  public:
    void show() override { cout << "Derived::show\n"; }
    void display() override { cout << "Derived::display\n"; }
};
int main() {
    Base* b = new Derived();
    b->show();
    b->display();
  return 0;
}





6. vtable for Base
Base_vtable:
+---------------------+
| &Base::show         |
| &Base::display      |
+---------------------+


7. vtable for Derived
Derived_vtable:
+------------------------+
| &Derived::show         |
| &Derived::display      |
+------------------------+



8. Object Layout in Memory
When executing:
Base* b = new Derived();


Object created:
Derived object:
+-------------------------------+
| vptr -> Derived_vtable ------+------> +------------------------+
|                               |        | &Derived::show         |
| (Base part)                   |        | &Derived::display      |
| (Derived part)                |        +------------------------+
+-------------------------------+




9. Runtime Call Resolution
Call:
b->show();


Runtime steps:
Step 1: Look inside object → get vptr
Step 2: vptr points to Derived_vtable
Step 3: Fetch entry for show()
Step 4: Call Derived::show()


Thus output:
Derived::show
Derived::display




10. Important Notes
✔ Each object of Base and Derived contains its own vptr
✔ vtable exists per class
✔ vptr is set inside constructor
✔ Virtual calls always resolved at runtime (dynamic dispatch)




11. Follow-up Example Question (Interview Level)
▶ Example: Only some functions overridden

class A {
  public:
    virtual void f1() { cout << "A::f1\n"; }
    virtual void f2() { cout << "A::f2\n"; }
};
class B : public A {
  public:
    void f1() override { cout << "B::f1\n"; }
};

vtable for B:
B_vtable:
+------------------+
| &B::f1           |
| &A::f2   (not overridden)  
+------------------+

Even if only one function is overridden, the vptr still points to a full table.




12. Coding Question with Explanation
Q1: What will be the output?
class X {
  public:
    virtual void fun() { cout << "X\n"; }
};
class Y : public X {
  public:
    void fun() { cout << "Y\n"; }
};
int main() {
    X x;
    Y y;
    X* p = &y;
    X* q = &x;

    p->fun(); // ?
    q->fun(); // ?
  return 0;
}
/*
Answer
Y
X
*/

Reason:
---> p points to a Y object → vptr points to Y_vtable → calls Y::fun.
---> q points to an X object → vptr points to X_vtable → calls X::fun.

Q2. Multiple Derived Classes
class A { public: virtual void f(){ cout<<"A\n"; } };
class B : public A { public: void f(){ cout<<"B\n"; } };
class C : public A { public: void f(){ cout<<"C\n"; } };
int main() {
    A* a;
    B b;
    C c;
    a = &b; a->f();  // ?
    a = &c; a->f();  // ?
   return 0;
}
/* 
Output:
B
C
*/



✅ 1. When is the vtable created?
✔ vtable is created at compile time (actually static memory allocation done during compilation/linking phase)
Explanation:
---> When the compiler sees a class with at least one virtual function, it generates a vtable for that class.
---> This vtable is stored in a global/static segment of the program (usually read-only data section: .rodata).
---> The vtable exists before the program starts executing (before main()).

So:
Component	Created At	                            Reason
vtable	    Compile time (during compile & link)	It is a compiler-generated static structure



✅ 2. When is the vptr created?
✔ vptr is created at run time when an object is constructed
Explanation:
---> vptr is not generated for the class; it is generated inside each object that belongs to a class with virtual functions.

So when you create an object:  Derived d;
---> during execution of the constructor, the compiler inserts code to set:
     d.vptr = &Derived_vtable;

So:
| Component                       | Created At                               | Reason                                          |
| ------------------------------- | ---------------------------------------- | ----------------------------------------------- |
| **vptr (inside. every object)** | **Runtime (during object construction)** | Because the object does not exist until runtime |


3. Full Summary (Interview-perfect answer)
| Item       | Created At                                         | Description                                                             |
| ---------- | -------------------------------------------------- | ----------------------------------------------------------------------- |
| **vtable** | **Compile Time** (actually emitted during linking) | One per class. Stored in static memory. Function pointer array.         |
| **vptr**   | **Run Time** (object creation time)                | One per object. Stored inside the object. Points to appropriate vtable. |



4. Visual Timeline
Compile Time
---> Compiler sees virtual keyword
---> Compiler generates a vtable for the class
---> The vtable is placed in binary (.rodata section)

     [Compile-Time Actions]
     Create vtable for Base
     Create vtable for Derived
     Emit them into final executable

Run Time
---> Program starts
---> Object is constructed
---> Constructor sets vptr for that object

     [Runtime Actions]
     Base() constructor → sets vptr → Base_vtable
     Derived() constructor → sets vptr → Derived_vtable





5. Example to illustrate timing
class Base {
  public:
    virtual void show() {}
};
int main() {
    Base b;   // vptr created now (runtime)
}

What happened?
✔ At compile time:
---> vtable for Base created

✔ At runtime:
---> object b created
---> inside b a hidden vptr allocated
---> constructor sets: b.vptr = &Base_vtable



6. Professional One-line Answer (For Interview)
---> The vtable is created at compile time, whereas the vptr is created at run time when the object is constructed.









✔ vtable creation timeline (WHEN and HOW it is created)
✔ vptr setup in constructors (WHAT exactly happens at runtime)
✔ memory layout diagrams (for base and derived objects)
✔ virtual call resolution (HOW C++ resolves virtual functions at runtime)



1. vtable Creation Timeline (Compile-Time Stages)
Stage 1 — Parsing Phase (Compiler Frontend)
---> When the compiler sees a class with at least one virtual function:
class Base {
  public:
    virtual void show();
    virtual void display();
};


It immediately decides:
---> This class needs a vtable
---> All its objects need a vptr



Stage 2 — vtable Generation (Compiler Backend)
---> The compiler constructs a virtual table for each class with virtual functions:

Base_vtable:
+----------------------------+
| &Base::show                |
| &Base::display             |
+----------------------------+




Stage 3 — Emitting into Binary (Link Time)
---> The vtable is placed into the final executable, typically in:
---> Read-only data section (.rodata)

This means:
✔ It exists before main() executes
✔ It never changes during program execution (except in inheritance overrides)

Final Verdict: vtable is created before the program starts.









2. vptr Setup in Constructors (Run-Time Stages)
When an object is created:
Base b;

Step 1 — Memory allocation
---> Memory is allocated for object b.

Step 2 — Constructor starts executing
---> Compiler inserts hidden code inside the constructor:
     b.vptr = &Base_vtable;

Step 3 — For derived classes, vptr is set multiple times
---> Example:
class Derived : public Base {
  public:
    void show() override;
};


When creating:
---> Derived d;

Constructor chain:
Base() constructor runs first:
    sets vptr → Base_vtable

Derived() constructor runs next:
    sets vptr → Derived_vtable

Thus the final vptr inside the object points to:
d.vptr --> Derived_vtable

Final Verdict: vptr is assigned during object construction at runtime.








3. Memory Layout Diagrams
class Base {
  public:
    int x;
    virtual void show();
    virtual void display();
};
class Derived : public Base {
  public:
    int y;
    void show() override;
    void display() override;
};



Base object layout
 Base object (in memory)
+-------------------------+
| vptr  --------------------+
+-------------------------+ |
| x                       | |
+-------------------------+ |
                            |
 Base_vtable                |
+----------------------------+
| &Base::show                |
| &Base::display             |
+----------------------------+

Derived object layout
 Derived object (in memory)
+-------------------------+
| vptr  --------------------+
+-------------------------+ |
| x (from Base)           | |
+-------------------------+ |
| y (own member)          | |
+-------------------------+ |
                            |
 Derived_vtable            |
+----------------------------+
| &Derived::show             |
| &Derived::display          |
+----------------------------+




4. Virtual Call Resolution (Runtime Dispatch)
Consider:
Base* b = new Derived();
b->show();

Step-by-step resolution:
Step 1: b points to a Derived object
b ---> [ Derived object ]
          |
          vptr --> Derived_vtable

Step 2: Virtual call compiled as:
b->show()  --->   b->vptr[ index_of_show ] ();


The compiler knows:
| Function  | Index in vtable |
| --------- | --------------- |
| show()    | 0               |
| display() | 1               |


Thus:
Call = b->vptr[0]

Step 3: vptr points to Derived_vtable
Derived_vtable[0] = &Derived::show

Step 4: call Derived::show()
Final output:
Derived::show


Final Summary (Interview Ready)
| Concept                     | When Created                  | Who Creates It   | Where Lives              |
| --------------------------- | ----------------------------- | ---------------- | ------------------------ |
| **vtable**                  | Compile time + link time      | Compiler         | Static memory (.rodata)  |
| **vptr**                    | Runtime (object construction) | Constructors     | Inside each object       |
| **vtable binding**          | Compile time                  | Compiler         | Binary image             |
| **vptr setup**              | Runtime                       | Constructor code | Object memory            |
| **Virtual call resolution** | Runtime                       | Processor + vptr | vptr → vtable → function |
